---
- name: Generate cartesian product of specified keys
  set_fact:
    specified_keys: "{{ project_dict | dict2items | map(attribute='key') | list | difference(['name', 'fork']) }}"

- name: Generate possible combinations when there is only one property
  set_fact:
    combinations: "{{ combinations | default([]) + [[item]] }}"
  loop: "{{ project_dict[specified_keys[0]] }}"
  when: specified_keys | length == 1

- name: Generate combinations when there are more than one properties
  set_fact:
    combinations: "{{ combinations | product(project_dict[specified_keys[i]]) | list }}"
  loop: "{{ range(specified_keys | length) }}"
  loop_control:
    loop_var: i
  when: i > 1 and specified_keys | length >= 2

- name: Combos for a list of strings
  set_fact:
    combos: "{{ combos | default([]) + [dict(specified_keys | zip([item]))] }}"
  loop: "{{ combinations }}"
  when: item | type_debug == 'str'

- name: Combos for a list of list of strings
  set_fact:
    combos: "{{ combos | default([]) + [dict(specified_keys | zip(item | flatten | list))] }}"
  loop: "{{ combinations }}"
  when: item | type_debug == 'list'

- name: Tag list elements with fork and project name
  set_fact:
    combos: "{{ combos | default([]) | map('combine', {'project': project_dict.name, 'fork': project_dict.fork}) | list }}"
  loop: "{{ combos }}"

- name: If no combinations, report just the project and the fork
  set_fact:
    combos: "{{ [{'project': project_dict.name, 'fork': project_dict.fork}] }}"
  when: combos | length == 0
